# Вопросы на собеседовании по языку C++

__1. Зачем нужен виртуальный деструктор?__


__Ответ:__ Чтобы избежать возможной утечки памяти или другого неконтролируемого поведения объекта, в логику работы которого включен вызов деструктора.

__Пример:__

```c++
class Base // базовый класс
{
public:
	virtual ~Base() {
		std::cout << "Hello from ~Base()" << std::endl;
	}
};

class Derived : public Base // наследуемый
{
public:
	virtual ~Derived() {
		// Здесь могла бы быть очистка ресурсов
		std::cout << "Hello from ~Derived()" << std::endl;
	}
};

Base *obj = new Derived();
delete obj;
```
__Output:__
`Hello from ~Derived()`
`Hello from ~Base()`

Без ключевого слова **virtual** у родительского класса **Base** деструктор порожденного класса не был бы вызван. Т.е. вызвался бы только **~Base()**:
**Output:**  
`Hello from ~Base()`

__2. Что стоит помнить при использовании исключений в конструкторе объекта?__

  
**Ответ:** Если исключение не обработано, то c логической точки зрения разрушается объект, который еще не создан, а с технической, так как он еще не создан, то и деструктор этого объекта **не будет** вызван
**Пример:**  

```c++
class Base
{
private: 
    HANDLE m_hFile;

public:
    Base()
    {
        std::cout << "Hello from Base()" << std::endl;
        m_hFile = ::CreateFileA(...);
        // Вызываем код, который в ходе своего выполнения бросает исключение
        SomeLib.SomeFunc(...);
    }

    virtual ~Base()
    {
        std::cout << "Hello from ~Base()" << std::endl;
        // Здесь мы планировали закрыть хэндл
        ::CloseHandle(m_hFile);
    }
};

try
{
    Base b;
}
catch(const std::exception &e)
{
    std::cout << "Exception message: " << e.what() << std::endl;
}

```

  
**Output:**  
`Hello from Base()`
`Exception message: Something failed`  
  
Я немного модифицировал предыдущий пример, чтобы проблема была наглядней. Здесь объект **m_hFile** (если был открыт) утечет т.к. до **CloseHandle()** выполнение не дойдет. Т.е. имеем такие же проблемы как в первом примере: возможная утечка ресурсов или другие проблемы из-за нарушения логики работы класса
Здесь могут спросить: «Как бы вы поступили при подобной ситуации». **Правильный ответ**: «Воспользовался бы умными указателями».
Оборачиваем в std::unique_ptr HANDLE. Теперь и без вызова деструктора **Base** хэндл будет закрыт, т.к. при уничтожении класса **Base** будет уничтожен объект **m_hFile**. Умным указателем будет вызван декструктор HANDLE и хэнлд будет успешно закрыт.

__3. Для каких целей применяется ключевое слово  const?__
  
**Ответ:** 
- Позволяет задать константность объекта
-  Позволяет задать константность указателя
-  Позволяет указать, что данный метод не модифицирует члены класса, т.е. сохраняет состояние объекта

**Пример 1. Не можем изменить значение объекта:**  

```c++
const int i = 1;
i = 2; // error C3892: 'i' : you cannot assign to a variable that is const

```

  
**Пример 2. Не можем изменить указатель на объект:**  

```c++
int i = 1;
int* const j(&i);
int k = 2;
*j = k; // Ok
j = &k; // error C3892: 'j' : you cannot assign to a variable that is const
```
  
**Пример 3. Не можем изменить члены класса:**  

```c++
class Foo
{
private:
    int i;
public:
    void func() const
    {
        i = 1; // error C3490: 'i' cannot be modified because it is being accessed through a const object
    }
```
**4. Как защитить объект от копирования?**

**Ответ:** Сделать **private** конструктор копирования и оператор **=** или воспользоваться **= delete** введенной в C++11
**Пример:**  

```c++
class NonCopyable
{
public:
    NonCopyable(){}

private:
    NonCopyable(NonCopyable&){}
    
private:
    void operator=(const NonCopyable&){}
};
NonCopyable a; 
NonCopyable b = a; // error C2248: 'NonCopyable::NonCopyable' : cannot access private member
a = b; // error C2248: 'NonCopyable::operator =' : cannot access private member
```
__5. В чем разница между  **struct**  и  **class**?__
 
**Ответ:** Практически ни в чем. В **struct** модификаторы доступа по умолчанию **public**, в **class**  **private**. Также отличается и наследование по умолчанию, у **struct** — **public**, у **class** — **private**.

**Пример:**  
```c++
struct Foo
{
    int i;
};
class Bar
{
    int i;
};

Foo a;
a.i = 1; // Ok
Bar b;
b.i = 1; // error C2248: 'Bar::i' : cannot access private member declared in class 'Bar'
```
__6. Каким свойством должен обладать объект, чтобы его можно было добавить в ассоциативные контейнеры в качестве ключа?__

**Ответ:** Т.к. значения в ассоциативных контейнерах хранятся отсортированными, то объект должен реализовывать оператор сравнения **<**, а остальные операторы сравнения могут быть выражены через него.
**Пример:**  

```c++
struct Foo
{
    int i;
};
inline bool operator < (const Foo & lhs, const Foo & rhs)
{
    return lhs.i < rhs.i;
}

std::set<Foo> data;
Foo a, b, c;
a.i = 7;
b.i = 1;
c.i = 6;
data.insert( a );
data.insert( b );
data.insert( c );
// Теперь в data элементы находятся в последовательности 1 6 7

```
Без реализации **operator <** объект класса Foo нельзя было бы добавить в **set**, т.к. был бы не определен их порядок внутри **set'а**.  
  
Для нахождения элемента в контейнеры STL сам определяет недостающие операторы из оператора меньше. Так например, чтобы вычислить нужный элемент STL проверяет меньше ли он текущего, далее больше ли, и если оба условия ложны значит элемент эквивалентен искомому.  
  
Помимо этого, для контейнеров может быть определен класс сравнения (**Comparison class**), в котором будет определена логика сравнения объектов, реализованная через тот же оператор меньше.

__7. Сколько в памяти занимает произвольная структура?__

  
**Ответ:**  **sizeof** всех членов + остаток для выравнивания (по умолчанию выравнивание 4 байта) + **sizeof** указателя на **vtable** (если есть виртуальные функции) + указатели на классы предков, от которых было сделано **виртуальное** наследование (размер указателя * количество классов)  
**Пример:**  

```c++
struct Foo
{
    int i;
    char a;
};

int size = sizeof(Foo); // 8 байт, хотя int + char = 5. Все дело в дефолтном выравнивании равном 4, т.е. размер должен быть кратен блоку в 4 байта.

// Установим выравнивание в 1 байт
#pragma pack(push, 1)
struct Foo
{
    int i;
    char a;
};
#pragma pack(pop)

int size = sizeof(Foo); // 5 байт
```
