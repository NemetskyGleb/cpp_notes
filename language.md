# Вопросы на собеседовании по языку C++

__1. Зачем нужен виртуальный деструктор?__


__Ответ:__ Чтобы избежать возможной утечки памяти или другого неконтролируемого поведения объекта, в логику работы которого включен вызов деструктора.

__Пример:__

```c++
class Base // базовый класс
{
public:
	virtual ~Base() {
		std::cout << "Hello from ~Base()" << std::endl;
	}
};

class Derived : public Base // наследуемый
{
public:
	virtual ~Derived() {
		// Здесь могла бы быть очистка ресурсов
		std::cout << "Hello from ~Derived()" << std::endl;
	}
};

Base *obj = new Derived();
delete obj;
```
__Output:__
`Hello from ~Derived()`
`Hello from ~Base()`

Без ключевого слова **virtual** у родительского класса **Base** деструктор порожденного класса не был бы вызван. Т.е. вызвался бы только **~Base()**:
**Output:**  
`Hello from ~Base()`

__2. Что стоит помнить при использовании исключений в конструкторе объекта?__

  
**Ответ:** Если исключение не обработано, то c логической точки зрения разрушается объект, который еще не создан, а с технической, так как он еще не создан, то и деструктор этого объекта **не будет** вызван
**Пример:**  

```c++
class Base
{
private: 
    HANDLE m_hFile;

public:
    Base()
    {
        std::cout << "Hello from Base()" << std::endl;
        m_hFile = ::CreateFileA(...);
        // Вызываем код, который в ходе своего выполнения бросает исключение
        SomeLib.SomeFunc(...);
    }

    virtual ~Base()
    {
        std::cout << "Hello from ~Base()" << std::endl;
        // Здесь мы планировали закрыть хэндл
        ::CloseHandle(m_hFile);
    }
};

try
{
    Base b;
}
catch(const std::exception &e)
{
    std::cout << "Exception message: " << e.what() << std::endl;
}

```

  
**Output:**  
`Hello from Base()`
`Exception message: Something failed`  
  
Я немного модифицировал предыдущий пример, чтобы проблема была наглядней. Здесь объект **m_hFile** (если был открыт) утечет т.к. до **CloseHandle()** выполнение не дойдет. Т.е. имеем такие же проблемы как в первом примере: возможная утечка ресурсов или другие проблемы из-за нарушения логики работы класса
Здесь могут спросить: «Как бы вы поступили при подобной ситуации». **Правильный ответ**: «Воспользовался бы умными указателями».
Оборачиваем в std::unique_ptr HANDLE. Теперь и без вызова деструктора **Base** хэндл будет закрыт, т.к. при уничтожении класса **Base** будет уничтожен объект **m_hFile**. Умным указателем будет вызван декструктор HANDLE и хэнлд будет успешно закрыт.

__3. Для каких целей применяется ключевое слово  const?__
  
**Ответ:** 
- Позволяет задать константность объекта
-  Позволяет задать константность указателя
-  Позволяет указать, что данный метод не модифицирует члены класса, т.е. сохраняет состояние объекта

**Пример 1. Не можем изменить значение объекта:**  

```c++
const int i = 1;
i = 2; // error C3892: 'i' : you cannot assign to a variable that is const

```

  
**Пример 2. Не можем изменить указатель на объект:**  

```c++
int i = 1;
int* const j(&i);
int k = 2;
*j = k; // Ok
j = &k; // error C3892: 'j' : you cannot assign to a variable that is const
```
  
**Пример 3. Не можем изменить члены класса:**  

```c++
class Foo
{
private:
    int i;
public:
    void func() const
    {
        i = 1; // error C3490: 'i' cannot be modified because it is being accessed through a const object
    }
```
**4. Как защитить объект от копирования?**

**Ответ:** Сделать **private** конструктор копирования и оператор **=** или воспользоваться **= delete** введенной в C++11
**Пример:**  

```c++
class NonCopyable
{
public:
    NonCopyable(){}

private:
    NonCopyable(NonCopyable&){}
    
private:
    void operator=(const NonCopyable&){}
};
NonCopyable a; 
NonCopyable b = a; // error C2248: 'NonCopyable::NonCopyable' : cannot access private member
a = b; // error C2248: 'NonCopyable::operator =' : cannot access private member
```
__5. В чем разница между  **struct**  и  **class**?__
 
**Ответ:** Практически ни в чем. В **struct** модификаторы доступа по умолчанию **public**, в **class**  **private**. Также отличается и наследование по умолчанию, у **struct** — **public**, у **class** — **private**.

**Пример:**  
```c++
struct Foo
{
    int i;
};
class Bar
{
    int i;
};

Foo a;
a.i = 1; // Ok
Bar b;
b.i = 1; // error C2248: 'Bar::i' : cannot access private member declared in class 'Bar'
```
__6. Каким свойством должен обладать объект, чтобы его можно было добавить в ассоциативные контейнеры в качестве ключа?__

**Ответ:** Т.к. значения в ассоциативных контейнерах хранятся отсортированными, то объект должен реализовывать оператор сравнения **<**, а остальные операторы сравнения могут быть выражены через него.
**Пример:**  

```c++
struct Foo
{
    int i;
};
inline bool operator < (const Foo & lhs, const Foo & rhs)
{
    return lhs.i < rhs.i;
}

std::set<Foo> data;
Foo a, b, c;
a.i = 7;
b.i = 1;
c.i = 6;
data.insert( a );
data.insert( b );
data.insert( c );
// Теперь в data элементы находятся в последовательности 1 6 7

```
Без реализации **operator <** объект класса Foo нельзя было бы добавить в **set**, т.к. был бы не определен их порядок внутри **set'а**.  
  
Для нахождения элемента в контейнеры STL сам определяет недостающие операторы из оператора меньше. Так например, чтобы вычислить нужный элемент STL проверяет меньше ли он текущего, далее больше ли, и если оба условия ложны значит элемент эквивалентен искомому.  
  
Помимо этого, для контейнеров может быть определен класс сравнения (**Comparison class**), в котором будет определена логика сравнения объектов, реализованная через тот же оператор меньше.

__7. Сколько в памяти занимает произвольная структура?__

  
**Ответ:**  **sizeof** всех членов + остаток для выравнивания (по умолчанию выравнивание 4 байта) + **sizeof** указателя на **vtable** (если есть виртуальные функции) + указатели на классы предков, от которых было сделано **виртуальное** наследование (размер указателя * количество классов)  
**Пример:**  

```c++
struct Foo
{
    int i;
    char a;
};

int size = sizeof(Foo); // 8 байт, хотя int + char = 5. Все дело в дефолтном выравнивании равном 4, т.е. размер должен быть кратен блоку в 4 байта.

// Установим выравнивание в 1 байт
#pragma pack(push, 1)
struct Foo
{
    int i;
    char a;
};
#pragma pack(pop)

int size = sizeof(Foo); // 5 байт
```
__8. Как сгенерировать pure virtual function call исключение?__

**Ответ:** Нужно вызвать чисто виртуальный метод в конструкторе родительского класса т.е. до создания дочернего, в котором этот метод реализован. Т.к. современный компилятор не даст это сделать напрямую, то нужно будет использовать промежуточный метод.  
**Пример:**  

```c++
class Base
{
public:
    Base()
    {
        base_func();
    }
    void base_func()
    {
        func(); // pure virtual function call exception
    }
    virtual void func() = 0;
};
class Derived : public Base
{
public:
    virtual void func()
    {
    }
};
```
__9. В чем отличие vector от deque?__

  
**Ответ:** Здесь вспоминают о наличии у **deque** методов **push_front** и **pop_front**. Но основное отличие в организации памяти, у **vector** она как у обычного Си-массива, т.е. последовательный и непрерывный набор байт, а у **deque** это фрагменты с разрывами. За счет этого отличия **vector** всегда можно привести к обычному массиву или скопировать целиком участок памяти, но зато у **deque** операции вставки/удаления в начало быстрее (**O(1)** против **O(n)**), ввиду того, что не нужно перемещать остальные значения.
__10. Что такое инкапсуляция?__

  
**Ответ (Wiki):** Инкапсуляция — свойство языка программирования, позволяющее объединить и защитить данные и код в объектe и скрыть реализацию объекта от пользователя (прикладного программиста). При этом пользователю предоставляется только спецификация (интерфейс) объекта.  
  
Пользователь может взаимодействовать с объектом только через этот интерфейс. Реализуется с помощью ключевого слова: public.  
  
Пользователь не может использовать закрытые данные и методы. Реализуется с помощью ключевых слов: private, protected.
__11. Что такое полиморфизм?__

  
**Ответ (Wiki):** Возможность объектов с одинаковой спецификацией иметь различную реализацию.
**Пример:**  

```c++
class Figure 
{
    ...
    void Draw() const;
    ...
};
 
class Square : public Figure 
{
    ...
    void Draw() const;
    ...
};
 
class Circle : public Figure 
{
    ...
    void Draw() const;
    ...
};
```
Т.е. есть базовый класс фигура, и от него унаследованы два класса квадрат и круг, имеющие **собственную** реализацию метода **Draw()**.
##### 15. В чем отличие malloc от new?

  
**Ответ:**  **malloc** — выделение блока памяти в стиле Си, опасное с точки зрения приведения типов (non-typesafe), т.к. возвращает **void *** и требует обязательного приведения. **new** — выделение блока памяти и последующий **вызов конструктора**, безопасное с точки зрения приведения типов (typesafe), т.к. тип возвращаемого значения определен заранее.  
  

__12. Что такое чисто виртуальный метод и абстрактный класс?__

  
**Ответ:** Чисто виртуальный метод — это метод, у которого отсутствует реализация. Абстрактный класс — это класс имеющий хотя бы один чисто виртуальный метод. Как следствие, экземпляр подобного класса не может быть создан т.к. отсутствует реализация виртуального метода.  
**Пример:**  

```c++
// Абстрактный класс
class Foo
{
public:
    // Чисто виртуальный метод
    virtual void func() = 0;
};
class Bar : public Foo
{
public:
    virtual void func()
    {
    }
};

Foo f; // error C2259: 'Foo' : cannot instantiate abstract class	
Bar b; // Ok

```

  

__13. Для чего используется вызов throw без аргументов?__

  
**Ответ:** Для повторного возбуждения предыдущего исключения и направления его следующему обработчику.  
**Пример:**  

```c++
try
{
    //....
    try
    {
        // Call something
    }
    catch(const std::exception& )
    {
        // Make/Check something..
        throw; // Пересылаем исключение следующему обработчику
    }
    //...
}
catch(const std::exception& e)
{
    std::cout << e.what() << std::endl;
}

```

  
  

__14. В чем различия между delete и delete[]?__

  
**Ответ:**  **delete** предназначен для уничтожения объектов, память под которые выделена при помощи **new()**. **delete[]** для объектов выделенных при помощи оператора **new[]()**.  
**Пример:**  

```c++
class Foo
{
};

Foo *pFoo = new Foo();
delete pFoo;
Foo *pFooArray = new Foo[10]();
delete[] pFoo;

```

  
При неправильном использовании оператора **delete** (например, **delete** вместо **delete[]**) результат будет: **undefined behavior**.  
  

__15. Что стоит учитывать при использовании auto_ptr?__

  
**Ответ:** Так как данный умный указатель реализует подход **разрушающего копирования**, то при присвоении его другому умному указателю оригинальный потеряет свое значение. А так же его нельзя использовать в стандартных STL контейнерах.  
**Пример:**  

```c++
std::auto_ptr<Foo> a(new Foo);
std::auto_ptr<Foo> b;
b = a; // a больше не ссылается на Foo

std::vector<std::auto_ptr<Foo>> v;
v.push_back(b); // error C2558: class 'std::auto_ptr<_Ty>' : no copy constructor available or copy constructor is declared 'explicit'

```

  
Также ввиду того, что в деструкторе **auto_ptr** вызывается оператор **delete**, нельзя хранить объекты созданные при помощи **new[]()**. Именно из-за этого нюанса **boost** предоставляет умные указатели в двух вариантах, для просто объекта и их коллекции, например, **shared_ptr** и **shared_array**.  
  

__16. Для чего используется ключевое слово volatile?__

  
**Ответ:** Для указания компилятору, что доступ к переменной может осуществляться из мест, неподконтрольных ему. А как следствие, что работу с данной переменной не нужно подвергать разного рода оптимизациям.  
**Пример:**  

```c++
volatile int i = 1; // Независимо от прочего кода, данная переменная не будет оптимизирована.

```

  
Т.е. если **volatile** присутствует в каком-то условии, которое не меняется со временем, то компилятор может оптимизировать его, чтобы избежать ненужных проверок, при использовании **volatile** компилятор скорее всего не будет этого делать.  
**Пример:**  

```c++
while (1) 
{
    if(i == 1)
    {
        // Какой-то код не изменяющий i
    }
}

// Если бы volatile отсутствовало, то компилятор мог бы переделать код на что-то аля:
if(i == 1) // Нет необходимости проверять i все время, если и так известно, что оно не изменяется
{
    while (1) 
    {
        // Какой-то код не изменяющий i
    }
}
```
